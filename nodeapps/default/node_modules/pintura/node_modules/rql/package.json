{
  "name": "rql",
  "version": "0.3.1",
  "author": {
    "name": "Kris Zyp"
  },
  "contributors": [
    {
      "name": "Vladimir Dronnikov",
      "email": "dronnikov@gmail.com"
    }
  ],
  "keywords": [
    "resource",
    "query",
    "uri"
  ],
  "description": "Query language for the web, NoSQL",
  "licenses": [
    {
      "type": "AFLv2.1",
      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L43"
    },
    {
      "type": "BSD",
      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L13"
    }
  ],
  "directories": {
    "lib": "."
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/kriszyp/rql"
  },
  "maintainers": [
    {
      "name": "Kris Zyp",
      "email": "kriszyp@gmail.com"
    }
  ],
  "mappings": {
    "patr": "http://github.com/kriszyp/patr/zipball/v0.2.1",
    "promised-io": "http://github.com/kriszyp/promised-io/zipball/v0.2.1"
  },
  "dependencies": {
    "promised-io": ">0.2.3"
  },
  "devDependencies": {
    "patr": ">0.2.6"
  },
  "icon": "http://packages.dojofoundation.org/images/persvr.png",
  "readme": "Resource Query Language (RQL) is a query language designed for use in URIs with object\nstyle data structures. This project includes the RQL specification and\nprovides a JavaScript implementation of query \nparsing and query execution implementation for JavaScript arrays. The JavaScript library\nsupports AMD and NodeJS/CommonJS module format so it can be run in the browser or\nin the server. RQL can be thought as basically a set of\nnestable named operators which each have a set of arguments. RQL is designed to\nhave an extremely simple, but extensible grammar that can be written in a URL friendly query string. A simple RQL\nquery with a single operator that indicates a search for any resources with a property of\n\"foo\" that has value of 3 could be written:\n\n    eq(foo,3)\n\nRQL is a compatible superset of standard HTML form URL encoding. The following query\nis identical to the query (it is sugar for the query above):\n\n    foo=3\n\nSuch that this can be used in URIs like:\n\n    http://example.org/data?foo=3\n\nJavaScript Library\n==============\n\nUsing the JavaScript library we can construct queries \nusing chained operator calls in JavaScript. We could\nwrite this query:\n\n    var Query = require(\"rql/query\").Query;\n    var fooEq3Query = new Query().eq(\"foo\",3);\n    \n    \n\nThe RQL grammar is based around standard URI delimiters. The standard rules for \nencoding strings with URL encoding (%xx) are observed. RQL also supersets FIQL. \nTherefore we can write a query that finds resources with a \"price\" property below\n10 with a \"lt\" operator using FIQL syntax:\n\n    price=lt=10\n\nWhich is identical (and sugar for call operator syntax known as the normalized form):\n\n    lt(price,10)\n\nOne can combine conditions with multiple operators with \"&\":\n\n    foo=3&price=lt=10\n\nIs the same as:\n\n    eq(foo,3)&lt(price,10)\n\nWhich is also the same as:\n\n    and(eq(foo,3),lt(price,10))\n\nWe can execute a query against a JavaScript array:\n\n\trequire(\"rql/js-array\").executeQuery(\"foo=3&price=lt=10\", {}, data)...\n\nThe | operator can be used to indicate an \"or\" operation. We can also use paranthesis\nto group expressions. For example:\n\n    (foo=3|foo=bar)&price=lt=10\n    \nWhich is the same as:\n\n    and(or(eq(foo,3),eq(foo,bar)),lt(price,10))\n    \nValues in queries can be strings (using URL encoding), numbers, booleans, null, undefined,\nand dates (in ISO UTC format without colon encoding). We can also denote arrays\nwith paranthesis enclosed, comma separated values. For example to find the objects\nwhere foo can be the number 3, the string bar, the boolean true, or the date for the\nfirst day of the century we could write an array with the \"in\" operator:\n\n    foo=in=(3,bar,true,2000-01-01T00:00:00Z)\n\nWe can also explicitly specify primitive types in queries. To explicitly specify a string \"3\",\nwe can do:\n\n    foo=string:3\n\nAny property can be nested by using an array of properties. To search by the bar property of\nthe object in the foo property we can do:\n\n    (foo,bar)=3\n    \nWe can also use slashes as shorthand for arrays, so we could equivalently write the nested\nquery:\n\n    foo/bar=3\n\nAnother common operator is sort. We can use the sort operator to sort by a specified property.\nTo sort by foo in ascending order:\n\t\n\tprice=lt=10&sort(+foo)\n\nWe can also do multiple property sorts. To sort by price in ascending order and rating in descending order:\n\n    sort(+price,-rating)\n\nThe aggregate function can be used for aggregation. To calculate the sum of sales for\neach department:\n\n    aggregate(departmentId,sum(sales))\n        \nHere is a definition of the common operators (individual stores may have support\nfor more less operators):\n\n* sort(&lt;+|->&lt;property) - Sorts by the given property in order specified by the prefix (+ for ascending, - for descending)  \n* select(&lt;property>,&lt;property>,...) - Trims each object down to the set of properties defined in the arguments\n* values(&lt;property>) - Returns an array of the given property value for each object\n* aggregate(&lt;property|function>,...) - Aggregates the array, grouping by objects that are distinct for the provided properties, and then reduces the remaining other property values using the provided functions\n* distinct() - Returns a result set with duplicates removed \n* in(&lt;property>,&lt;array-of-values>) - Filters for objects where the specified property's value is in the provided array\n* out(&lt;property>,&lt;array-of-values>) - Filters for objects where the specified property's value is not in the provided array\n* contains(&lt;property>,&lt;value | expression>) - Filters for objects where the specified property's value is an array and the array contains any value that equals the provided value or satisfies the provided expression.\n* excludes(&lt;property>,&lt;value | expression>) - Filters for objects where the specified property's value is an array and the array does not contain any of value that equals the provided value or satisfies the provided expression.\n* limit(count,start,maxCount) - Returns the given range of objects from the result set\n* and(&lt;query>,&lt;query>,...) - Applies all the given queries\n* or(&lt;query>,&lt;query>,...) - The union of the given queries\n* eq(&lt;property>,&lt;value>) - Filters for objects where the specified property's value is equal to the provided value\n* lt(&lt;property>,&lt;value>) - Filters for objects where the specified property's value is less than the provided value\n* le(&lt;property>,&lt;value>) - Filters for objects where the specified property's value is less than or equal to the provided value\n* gt(&lt;property>,&lt;value>) - Filters for objects where the specified property's value is greater than the provided value\n* ge(&lt;property>,&lt;value>) - Filters for objects where the specified property's value is greater than or equal to the provided value\n* ne(&lt;property>,&lt;value>) - Filters for objects where the specified property's value is not equal to the provided value\n* rel(&lt;relation name?>,&lt;query>) - Applies the provided query against the linked data of the provided relation name.\n* sum(&lt;property?>) - Finds the sum of every value in the array or if the property argument is provided, returns the sum of the value of property for every object in the array \n* mean(&lt;property?>) - Finds the mean of every value in the array or if the property argument is provided, returns the mean of the value of property for every object in the array \n* max(&lt;property?>) - Finds the maximum of every value in the array or if the property argument is provided, returns the maximum of the value of property for every object in the array \n* min(&lt;property?>) - Finds the minimum of every value in the array or if the property argument is provided, returns the minimum of the value of property for every object in the array \n* recurse(&lt;property?>) - Recursively searches, looking in children of the object as objects in arrays in the given property value\n* first() - Returns the first record of the query's result set\n* one() - Returns the first and only record of the query's result set, or produces an error if the query's result set has more or less than one record in it.\n* count() - Returns the count of the number of records in the query's result set\n\nIf you are writing an implementation of RQL for a database or other storage endpoint, or want to introspect queries, you can use the parsed query data \nstructures. You can parse string queries with parser module's parseQuery function.\nQuery objects have a \"name\" property and an \"args\" with an array of the arguments.\nFor example:\n\n\trequire(\"rql/parser\").parseQuery(\"(foo=3|foo=bar)&price=lt=10\") ->\n\t{\n\t\tname: \"and\",\n\t\targs: [\n\t\t\t{\n\t\t\t\tname:\"or\",\n\t\t\t\targs:[\n\t\t\t\t\t{\n\t\t\t\t\t\tname:\"eq\",\n\t\t\t\t\t\targs:[\"foo\",3]\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname:\"eq\",\n\t\t\t\t\t\targs:[\"foo\",\"bar\"]\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:\"lt\",\n\t\t\t\targs:[\"price\",10]\n\t\t\t}\n\t\t]\n\t}\n\t\t\t\t\nInstallation\n========\n\nIt is recommended that you install RQL such that it is available in require statements\nunder the \"rql\" path. This can easily be done with a package mapping compliant module\nloader like [Nodules](http://github.com/kriszyp/nodules) by using a mapping in your \npackage.json:\n\n    \"mappings\": {\n\t  \"rql\": \"http://github.com/kriszyp/perstore/zipball/master\"\n    }\n\nRQL Templating\n--------------\n\nRQL \n\nLicensing\n--------\n\nThe RQL implementation is part of the Persevere project, and therefore is licensed under the\nAFL or BSD license. The Persevere project is administered under the Dojo foundation,\nand all contributions require a Dojo CLA.\n\nProject Links\n------------\n\nSee the main Persevere project for more information:\n\n### Homepage:\n\n* [http://persvr.org/](http://persvr.org/)\n\n### Source & Download:\n\n* [http://github.com/kriszyp/perstore/](http://github.com/kriszyp/perstore)\n\n### Mailing list:\n\n* [http://groups.google.com/group/persevere-framework](http://groups.google.com/group/persevere-framework)\n\n### IRC:\n\n* [\\#persevere on irc.freenode.net](http://webchat.freenode.net/?channels=persevere)\n",
  "readmeFilename": "README.md",
  "_id": "rql@0.3.1",
  "dist": {
    "shasum": "8a85361219bec7f782ad9029bdef792a11a8ad4a"
  },
  "_from": "rql@>=0.3.1"
}
