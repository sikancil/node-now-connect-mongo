{
  "name": "pintura",
  "version": "0.3.1",
  "author": {
    "name": "Kris Zyp"
  },
  "email": "kriszyp@gmail.com",
  "description": "JSGI-based RESTful JSON/JavaScript server",
  "contributors": [
    {
      "name": "Vladimir Dronnikov",
      "email": "dronnikov@gmail.com"
    }
  ],
  "keywords": [
    "rest",
    "database",
    "web",
    "json",
    "persevere"
  ],
  "mappings": {
    "perstore": "http://github.com/kriszyp/perstore/zipball/v0.2.4",
    "templify": "http://github.com/dmachi/templify/zipball/master",
    "promised-io": "jar:http://github.com/kriszyp/promised-io/zipball/v0.2.3!/",
    "patr": "jar:http://github.com/kriszyp/patr/zipball/v0.2.6!/",
    "tunguska": "http://github.com/kriszyp/tunguska/zipball/v0.2.4",
    "jsgi-node": "http://github.com/kriszyp/jsgi-node/zipball/v0.2.5",
    "node-formidable": "http://github.com/felixge/node-formidable/zipball/v0.9.8"
  },
  "overlay": {
    "narwhal": {
      "mappings": {
        "uri": "url",
        "jsgi/multipart": "./engines/rhino/lib/jsgi/multipart.js"
      }
    },
    "node": {
      "mappings": {
        "jsgi/multipart": "./engines/node/lib/jsgi/multipart.js"
      }
    }
  },
  "licenses": [
    {
      "type": "AFLv2.1",
      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L43"
    },
    {
      "type": "BSD",
      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L13"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/kriszyp/tunguska"
  },
  "directories": {
    "lib": "."
  },
  "maintainers": [
    {
      "name": "Kris Zyp",
      "email": "kriszyp@gmail.com"
    }
  ],
  "dependencies": {
    "tunguska": ">=0.3.0",
    "rql": ">=0.3.1",
    "websocket-server": ">=1.4.01",
    "perstore": ">=0.3.0",
    "promised-io": ">=0.3.0",
    "formidable": ">=1.0.0",
    "templify": ">=0.9.0",
    "jsgi-node": ">=0.2.5"
  },
  "devDependencies": {
    "patr": ">=0.2.6"
  },
  "readme": "[Pintura](http://www.google.com/maps?f=q&source=s_q&hl=en&geocode=&q=pintura&sll=40.554798,-111.881839&sspn=0.009211,0.016351&ie=UTF8&hq=&hnear=Pintura,+Washington,+Utah&ll=37.31666,-113.171539&spn=0.308538,0.523224&t=p&z=11)\r\nis a cross-platform server side JavaScript based REST architecture web framework \r\nusing standards based HTTP client/server interaction with a focus on JSON formatted data. \r\nPintura gives you out of the box RESTful HTTP/JSON interface to data, you can simply\r\ncreate data models and Pintura automatically provides an HTTP interface. Pintura consists of reusable \r\n[CommonJS](http://wiki.commonjs.org/) modules and \r\n[JSGI](http://jackjs.org/jsgi-spec.html) middleware such that it can be used on any \r\nJSGI compliant JavaScript platform, but is tested on Node.js and Jack 0.3. Pintura \r\nforms the core of the [Persevere](http://www.persvr.org/) 2.0 framework which is \r\ndesigned for rich Internet applications that rely heavily on Ajax-driven data \r\ncommunication from the browser. To learn more about features, capabilities, and philosophy of\r\nPintura see the [introduction to Pintura](http://www.sitepen.com/blog/2010/01/22/introducing-pintura/).\r\nThe [getting started with Pintura](http://www.sitepen.com/blog/2010/01/25/getting-started-with-pintura/) \r\narticle provides a great starting point for using Pintura to build Persevere applications.\r\nPintura is primarily composed of JSGI middleware components, and these components\r\nare [described here](http://www.sitepen.com/blog/2010/03/04/pintura-jsgi-modules/).\r\n\r\nSetup Pintura\r\n=================\r\n\r\nOne of the easiest way to get started with Pintura is start with the \r\n[Persevere example app](http://github.com/kriszyp/persevere-example-wiki),\r\nwhich can be downloaded and started with [Nodules](http://github.com/kriszyp/nodules).\r\nIt is recommended that you install Pintura such that it is available in require statements\r\nunder the \"pintura\" path. This can easily be done with a package mapping compliant module\r\nloader like [Nodules](http://github.com/kriszyp/nodules) by using a mapping in your \r\npackage.json (and then Pintura will be automatically downloaded for you):\r\n\r\n    \"mappings\": {\r\n\t    \"pintura\": \"jar:http://github.com/kriszyp/pintura/zipball/master!/lib/\"\r\n    }\r\n\r\nYou can then use \"app\" property from require(\"pintura/pintura\") as a JSGI application. \r\nWith [jsgi-node](http://github.com/kriszyp/jsgi-node) you can start Pintura:\r\n\r\n    require(\"jsgi-node\").start(require(\"pintura/pintura\").app); \r\n\r\nOr with Jack:\r\n\r\n    exports.app = require(\"pintura/pintura\").app;\r\n    \r\nYou can see a more in-depth example of serving static files in combination with Pintura\r\nin the Persevere example app [startup file](http://github.com/kriszyp/persevere-example-wiki/blob/master/lib/index.js).\r\n \r\nUsing Pintura\r\n===========\r\n\r\nPersevere applications are generally built upon models, which act as classes for data.\r\n[Perstore](http://github.com/kriszyp/perstore) is the persistence library that is used \r\nby Persevere for defining models. Models defined with Perstore are automatically\r\nmade accessible through HTTP by Pintura. A simple example of a model is:\r\n\r\n    var Model = require(\"perstore/model\").Model,\r\n    \tstore = require(\"perstore/mongodb\").MongoDB(\"Product\");\r\n    Product = Model(\"Product\",store, {\r\n        properties: {\r\n            name: String\r\n            // we can define other properties, all \r\n        },\r\n        // we can define handlers\r\n        put: function(object, directives){\r\n            object.updated = new Date();\r\n            store.put(object, directives);\r\n        }\r\n    }); \r\n\r\nHTTP/REST Basics\r\n----------------\r\n\r\nWith Persevere we can automatically interact with this data model through standard\r\nHTTP requests:\r\n\r\n* GET /{model}/{id} - Gets the object with the given id from the model store.\r\n* PUT /{model}/{id} - Updates or creates object with the given id in the model store.\r\n* DELETE /{model}/{id} - Deletes the object with the given id from the model store.\r\n* POST /{model}/ - Creates or incrementally updates an object in model store.\r\n\r\nPintura converts HTTP requests to method calls on the model. When an HTTP request\r\nis received it is converted to a call to the model of the form:\r\n\r\n    {model}.{httpMethod}({id or body},metadata);\r\nFor example if a request is received:\r\n\r\n    GET /Product/33 \r\n\r\nThis will result in a call to the model like:\r\n\r\n    Product.get(\"33\", metadata); \r\n\r\nFor the model above, there is no \"get\" method defined, so the default \"get\" handler\r\nwould be used, which delegates to the store to get the object by id. If we made a\r\nrequest like:\r\n\r\n    PUT /Product/33 \r\n\r\nThis would call the \"put\" handler defined in the model above.\r\nOne can also query stores through HTTP. Requests of the form /{model}/?{query}\r\nare passed through to the model by calls to the \"query\" method on the model.\r\nPerstore provides \r\n[query parsing capabilities](http://github.com/kriszyp/perstore) and stores implement \r\nquery execution (dependent on the capabilities of the DB).\r\nAn example of a query:\r\n\r\n    GET /Product/?type=shoe&price=lt=20&sort(-rating)\r\n\r\nSecurity\r\n========\r\n\r\nPersevere's facet-based security model forms the foundation of access control and\r\nis [described in this article](http://www.sitepen.com/blog/2010/03/08/object-capability-model-and-facets-in-perstorepintura/).\r\nFacets are used to define the different levels of access for models. Pintura's security\r\nconfiguration object can then be configured to define how users are authenticated\r\nand which facets or access levels each user is given. The security configuration object\r\nis available at require(\"pintura/pintura\").config.security. The primary functions\r\nthat can be overriden are:\r\n\r\n* authenticate(username, password) -  The authenticate method\r\nallows you to define a custom authentication method and defaults to authenticating\r\nagainst the auto-generated User model. Should return a user object.\r\n* getAllowedFacets(user, request) - Allows you to define which facets are available\r\nfor a given user. This should return an array of facets. By default this grants \r\nfull access to everything (the require(\"pintura/security\").FullAccess facet) for all users.\r\n* createUser(username, password) - This should create a new user for with the given\r\ncredentials.\r\n* getUsername(user) - Should return the name of the given user.\r\n* {g|s}etUserClass - Retrieve or set the user class used to find users\r\n* {g|s}etAuthClass - Retrieve or set the authentication class used to find authentication tokens\r\n\r\nError Handling\r\n===========\r\n\r\nPintura includes middleware for catching errors and converting them to appropriate\r\nHTTP error status codes. The following uncaught errors (until the error middleware catches them)\r\nare translated:\r\n\r\n* URIError - 400\r\n* TypeError - 403\r\n* require(\"perstore/errors\").NotFoundError - 404\r\n* require(\"perstore/errors\").PreconditionFailed - 412\r\n* require(\"perstore/errors\").AccessError - if user is authenticated 403, if not 401\r\n* require(\"perstore/errors\").MethodNotAllowedError - 405\r\n* RangeError - 416\r\n* Other errors - 500 or if the error object has a \"status\" property, that will be used\r\n\r\nContent Negotiation\r\n===============\r\n\r\nOne of the core concepts of the REST architecture is content negotiation which permits\r\nmultiple views or representations of resources or objects. Providing content negotiation\r\nis a key functionality that Pintura provides. Pintura utilizes a set of media type handlers\r\nto find the best representation for serializing (or deserializing) data. Pintura comes\r\nwith several media type handlers including:\r\n \r\n* json � JSON media handler\r\n* javascript � Similar to the JSON media handler, but will serialize to additional JavaScript specific types such as dates, NaN, functions, and other types that do not exist in JSON.\r\n* multipart-form-data and url-encoded � Used for parsing form data.\r\n* csv - Comma separated values\r\n* atom - Atom based view\r\n* html - A very simple HTML view of data.\r\n\r\nTo request a JSON view of data, include an Accept header in your HTTP request:\r\n\r\n    Accept: application/json\r\n\r\nAccept headers can include multiple options and quality values. By default application/javascript\r\nis considered the highest quality represention by Pintura (it is basically the same as JSON\r\nbut also can include date literals and special numeric types like NaN and Infinite).\r\n\r\nCreating new media types is common way to extend Pintura with additional formats.\r\nTo create a new media type handler, use the Media constructor from the \"media\" module.\r\nThis constructor takes an object argument with four properties:\r\n\r\n* mediaType - The name of the media type.\r\n* quality - A numeric value indicating the quality of the media type (generally a number from 0 - 1).\r\n* serialize - A function that is called to serialize the data (JavaScript objects or arrays) to string output for the response.\r\n* deserialize - A function that is called to deserialize the request input data to JavaScript objects or arrays.\r\n\r\n\r\nPaging/Range Requests\r\n-------------------\r\n\r\nPintura can handle requests for \"pages\" of data, query results with start and ending\r\nindex limits, through Range headers. To request items 10 through 19 of a query,\r\ninclude a Range header:\r\n\r\n    GET /Product/?type=shoe\r\n    Range: items=10-19\r\n\r\nThe server will return a Content-Range header indicating the range returned and total\r\ncount of the results. \r\n\r\nBulk Updates and Comet\r\n================\r\n\r\nPintura utilizes the message/* category of media types for indicating a set of requests \r\nor messages. Normally each HTTP request triggers one action in the store in its own\r\ntransaction, but a \r\nrequest with a content type of message/sub-type (usually message/json or message/javascript)\r\nwill be treated as a set of requests\r\nthat are all processed within one transaction. This allows you to do several updates\r\nwith one HTTP request. For request with a set of messages, the body should be an\r\narray of objects, where each object can have the following properties (only \"method\" is required):\r\n\r\n* to - The id/path of the target object of the action. This is resolved relative to the path of the request URI.\r\n* method - The method to execute, can be \"get\", \"put\", \"post\", \"subscribe\", or any other method on the target store.\r\n* body - The body of the request; the main payload of data.\r\n* queryString - query string\r\n* id - A message id, any subsequent message with the same id should be ignored (allows for idempotent messages) \r\n* metadata - Any metadata needed for the request\r\n\r\nFor example, updating two objects could be done:\r\n\r\n    POST /Product/\r\n    Content-Type: message/json \r\n    Accept: message/json\r\n    \r\n    [\r\n      {to:\"2\", method:\"put\", body:{name:\"updated 2\"}, id: 1},\r\n      {to:\"3\", method:\"put\", body:{name:\"updated 3\"}, id: 2}\r\n    ]\r\n    \r\nThe message/* media type can also be used in Accept headers to indicate that a response\r\nwith a set of messages should be returned. This should be used for bulk updates. A\r\nresponse will be an array of objects where each object may have the following properties:\r\n\r\n* from - The id/path of the object that was acted on \r\n* body - The body of the response\r\n* id - The id of the message that this message is in response to\r\n* type - The type of the action that was executed\r\n\r\nAn example response (for the requests above):\r\n\r\n    Content-Type: message/json\r\n    \r\n    [\r\n      {\"from\":\"2\", \"body\":{\"name\":\"updated 2\"}, \"id\": 1},\r\n      {\"from\":\"3\", \"body\":{\"name\":\"updated 3\"}, \"id\": 2}\r\n    ]\r\n\r\nReal-Time/Comet\r\n-----\r\n\r\nThe message/* media type can also be useful for real-time notification of events, AKA\r\ncomet. Stores and models that support notifications can return observable objects, typically\r\nthrough the \"subscribe\" method, to indicate that multiple events may be emitted that\r\ncan later be delivered to the client. When message requests are observable instead of\r\ndirect value, responses will not be sent to the client until there is a message ready to be sent.\r\nFor example, to subscribe to all events that take place on /User/john:\r\n\r\n    POST /User/\r\n    Content-Type: message/json\r\n    Client-Id: 251ab4ac9312f\r\n    Accept: message/json\r\n    \r\n    [\r\n      {to:\"john\", method:\"subscribe\"}\r\n    ]\r\n\r\nThe response to the client will be delayed until an event/message for /User/john occurs.\r\n\r\nFor maximum browser compatibility, typically long-polling is used for comet applications.\r\nHowever, there is always a time gap between responses and the next request from the\r\nbrowser. Consequently for continuous gap-free subscriptions, it can be highly useful\r\nto emulate a continuous connection or queue for messages. This can be done by \r\nincluding a Client-Id header. Clients can generate a random id, and repeated connect\r\nusing the same client id. Between requests, any events (from subscriptions) will be\r\npushed into a queue for the given client id until the next request.\r\n\r\nThe Client-Id header can be included in standard requests as well, allowing other operations\r\nto add event sources and subscriptions to the current client queue. \r\n\r\nSome browsers support XHR streaming and do not require long-polling repeated reconnections.\r\nIf you wish to use streaming, include a Streaming header:\r\n\r\n    Streaming: true\r\n    \r\nThe response will continue indefinitely, sending new messages as they occur.  \r\n\r\nCross domain support\r\n-------------------\r\n\r\nPintura includes support for cross-domain requests from the browser/JavaScript through\r\nJSONP, window.name, or CORS. To make a request with JSONP, you can do add a callback\r\nparameter\r\n\r\n    /Product/33?callback=my_callback\r\n\r\nSessions\r\n========\r\n\r\nPintura provides session management through session middleware. This middleware\r\nadds a getSession(createIfNecessary, expires) method to the request object. There is\r\nalso a statically accessible exported function for accessing sessions:\r\n\r\n    require(\"pintura/jsgi/session\").getCurrentSession(createIfNecessary, expires)\r\n\r\nThe session object is a persistent object and therefore the save() method that must \r\nbe called if any changes are made to the session object (that need to be persisted to \r\nfuture requests).\r\n     \r\nCross-Site Request Forgery Protection\r\n==========================\r\n\r\nPintura provides CSRF protection to safeguard against malicious attempts to change\r\ndata from other websites. This protection means that requests must prove that they\r\nare from your (same-origin) page and are therefore authorized requests. XHR requests\r\ncan be validated by including a Client-Id header (with any value) to prove that the request\r\nwas generated through XHR. Non-XHR requests (such as form-based requests) can prove\r\ntheir same-origin validation by including the cookie value from the \"pintura-session\" in\r\na \"pintura-session\" query parameter.\r\n\r\nIf a request is not provably same-origin, the request object will include a \"crossSiteForgeable\"\r\nproperty value of true to indicate that it should be regarded with suspicion.\r\n \r\nJSON-RPC\r\n========\r\nPintura supports JSON-RPC to call methods on objects. One can call a method on a\r\npersisted object by using the URL for the object, and JSON-RPC encoded request entity\r\nthat describes the method invocation to make. For example:\r\n\r\n    POST /Product/33\r\n    Content-Type: application/json\r\n    Accept: application/json\r\n    \r\n    {\r\n      method:\"addNote\",\r\n      params:[\"cool product\"],\r\n      id:\"call1\"\r\n    }\r\n\r\nPintura will then lookup the object with the id of \"/Product/33\" and call object.addNote(\"cool product\").\r\nThe return value or thrown error from the call will be returned in a JSON-RPC response. \r\n\r\n### Homepage:\r\n\r\n* [http://persvr.org/](http://persvr.org/)\r\n\r\n### Source & Download:\r\n\r\n* [http://github.com/kriszyp/pintura/](http://github.com/kriszyp/pintura)\r\n\r\n### Mailing list:\r\n\r\n* [http://groups.google.com/group/persevere-framework](http://groups.google.com/group/persevere-framework)\r\n\r\n### IRC:\r\n\r\n* [\\#persevere on irc.freenode.net](http://webchat.freenode.net/?channels=persevere)\r\n\r\nPintura is part of the Persevere project, and therefore is licensed under the\r\nAFL or BSD license. The Persevere project is administered under the Dojo foundation,\r\nand all contributions require a Dojo CLA.",
  "readmeFilename": "README.md",
  "_id": "pintura@0.3.1",
  "dist": {
    "shasum": "819a6bce18e15743e34396037e2052c29c63f5d7"
  },
  "_from": "pintura@*"
}
